
SELECT * FROM EMP
SELECT * FROM DEPT
SELECT * FROM SALGRADE

--CROSS JOIN
SELECT ENAME,LOC FROM EMP,DEPT
SELECT ENAME,DNAME FROM EMP,DEPT
SELECT SAL,HISAL FROM EMP,SALGRADE

--EQI JOIN
SELECT ENAME,LOC FROM EMP,DEPT WHERE EMP.DEPNO=DEPT.DEPNO

--NON EQI JOIN
SELECT ENAME,GRADE FROM EMP,SALGRADE WHERE SAL BETWEEN LOSAL AND HISAL

--SELF JOIN
SELECT E.ENAME EMPLOYEE,M.ENAME MANAGER FROM EMP E, EMP M WHERE E.MGR=M.EMPNO


--Full OUTER JOIN
SELECT EMPNO,ENAME,DNAME,LOC FROM DEPT D
FULL OUTER JOIN EMP  E
ON
E.DEPNO=D.DEPNO
order by ENAME

-- LEFT OUTER JOIN
SELECT COMM,DNAME FROM EMP  E
left OUTER JOIN DEPT D
ON
E.DEPNO=D.DEPNO

SELECT ENAME FROM EMP

--  WITH HELP OF OUTER JOIN DISPLAY WHO DOES NOT WORK IN ANY DEPARTMENT

SELECT * FROM EMP  E
FULL OUTER JOIN DEPT D
ON
E.DEPNO=D.DEPNO
WHERE E.DEPNO IS NULL


--INDEX FOR SEARCHING FASTER

CREATE INDEX T1 ON EMP (ENAME)

select * from EMP

drop index  T1 ON EMP 
-- DISPLAY EMPLOYEE NAME, DEPARTMENT NAME AND GRADE OF EACH EMPLOYEE (NON-EQI JOIN)

SELECT E.ENAME,D.DNAME,S.GRADE 
FROM EMP E
FULL OUTER JOIN DEPT D
ON
E.DEPNO=D.DEPNO,SALGRADE S 
WHERE E.SAL BETWEEN S.LOSAL AND HISAL

--DISPLAY EMPLOYEE NAME AS WELL AS NAME OF MANAGER (SELF-JOIN)

SELECT E.ENAME EMPLOYEE,M.ENAME MANAGER
FROM EMP  E,EMP M
WHERE E.MGR=M.EMPNO

--DISPLAY  DATE OF EMPLOYEE WHO WHERE HIRED BEFORE HIRING OF MANAGER(SELF-JOIN)

SELECT E.ENAME EMPLOYEE,M.ENAME MANAGER, E.HIREDATE "EMP HIRE DATE",M.HIREDATE "MGR HIRE DATE"
FROM EMP  E,EMP M
WHERE E.MGR=M.EMPNO
AND DATEDIFF(DY,E.HIREDATE,M.HIREDATE)>=1

--SUB QUERY
SELECT * FROM EMP WHERE DEPNO IN
(SELECT DEPNO FROM EMP WHERE ENAME LIKE 'SCOTT' OR ENAME LIKE 'ALLEN')

SELECT * FROM EMP WHERE DEPNO IN
(SELECT DEPNO FROM EMP WHERE ENAME LIKE 'SCOTT' OR ENAME LIKE 'ALLEN')

SELECT SUM(SAL) "SUM OF THE SALARY",AVG(SAL) "AVERAGE OF SALARY",COUNT(EMPNO) "NUM OF EMP WORKING" FROM EMP GROUP BY DEPNO


CREATE TRIGGER [NEW_TRIGGER]
ON EMP
AFTER  {[INSERT],[UPDATE],[DELETE]}
[NOT FOR REPLICATION]
AS
{sql_statements}
 -- trigger

CREATE TRIGGER  newtrigger 
ON MARK_SHEET
FOR INSERT
AS BEGIN
UPDATE MARK_SHEET SET MARK_SHEET.TOTAL_PERCENTAGE = ((MARK_SHEET.MARK_OBTAINED/MARK_SHEET.TOTAL_MARK)*100)
END

select * from MARK_SHEET

insert into MARK_SHEET values (7,3534,'Kame','Physics',67,100,null)





DROP TRIGGER sampletrigger;

























































































ON 
MARK_SHEET  
  for INSERT 
  AS BEGIN
UPDATE MARK_SHEET SET MARK_SHEET.TOTAL_PERCENTAGE = ((MARK_SHEET.MARK_OBTAINED/MARK_SHEET.TOTAL_MARK)*100)
END;

SELECT * FROM MARK_SHEET

drop TRIGGER  sampletrigger 

-- TRY AND CATCH
CREATE PROCEDURE usp_ExampleProc  
AS  
    SELECT * FROM NonexistentTable;  
GO  
  
BEGIN TRY  
    EXEC usp_ExampleProc;  
END TRY  
BEGIN CATCH  
    SELECT   
        ERROR_NUMBER() AS ErrorNumber  
        ,ERROR_MESSAGE() AS ErrorMessage;  
END CATCH;  

BEGIN TRY  

-- Generate a divide-by-zero error.  
    SELECT 1/0;  
END TRY  
BEGIN CATCH  
    SELECT  
        ERROR_NUMBER() AS ErrorNumber  
        ,ERROR_SEVERITY() AS ErrorSeverity  
        ,ERROR_STATE() AS ErrorState  
        ,ERROR_PROCEDURE() AS ErrorProcedure  
        ,ERROR_LINE() AS ErrorLine  
        ,ERROR_MESSAGE() AS ErrorMessage;  
END CATCH;  
GO

CREATE PROC usp_dividess(
@a decimal,
@b decimal,
@c decimal output
) AS
BEGIN
BEGIN TRY
SET @c = @a / @b;
END TRY
BEGIN CATCH
SELECT
ERROR_NUMBER() AS ErrorNumber
,ERROR_SEVERITY() AS ErrorSeverity
,ERROR_STATE() AS ErrorState
,ERROR_PROCEDURE() AS ErrorProcedure
,ERROR_LINE() AS ErrorLine
,ERROR_MESSAGE() AS ErrorMessage;
END CATCH
END;
GO

BEGIN TRY
SELECT 10/0 AS Result;
END TRY
BEGIN CATCH
SELECT ERROR_MESSAGE() AS [Error Message]
,ERROR_LINE() AS ErrorLine
,ERROR_NUMBER() AS [Error Number]
,ERROR_SEVERITY() AS [Error Severity]
,ERROR_STATE() AS [Error State]
END CATCH

